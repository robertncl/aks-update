#
# Workflow: Update Single AKS Cluster
#
# Description:
# This workflow automates the process of upgrading a single Azure Kubernetes Service (AKS)
# cluster. It can be triggered manually and creates a GitHub Issue to track the
# progress of the upgrade.
#
# Permissions:
# - contents: read - To checkout the repository code.
# - issues: write - To create and manage GitHub Issues for tracking.
#
name: Update Single AKS Cluster

permissions:
  contents: read
  issues: write

#
# Trigger: workflow_dispatch
#
# This allows the workflow to be run manually from the GitHub Actions UI.
#
# Inputs:
# - resource_group: The name of the Azure Resource Group containing the AKS cluster.
# - cluster_name: The name of the AKS cluster to be upgraded.
# - aks_version: The target Kubernetes version. If left empty, the workflow will
#                automatically determine the latest available stable (non-preview) version.
#
on:
  workflow_dispatch:
    inputs:
      resource_group:
        description: 'Resource Group Name'
        required: true
        type: string
      cluster_name:
        description: 'AKS Cluster Name'
        required: true
        type: string
      aks_version:
        description: 'Kubernetes Version (leave empty for latest)'
        required: false
        type: string

jobs:
  update-aks:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout repository
      # Checks out the repository code so that the workflow can access any scripts or files.
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Azure Login
      # Authenticates with Azure using credentials stored in GitHub secrets.
      - name: Azure Login
        uses: azure/login@v1 # Using v1 for broader compatibility, v2 is also fine
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}

      # Step 3: Determine Target Kubernetes Version
      # This step determines the Kubernetes version to upgrade to.
      # - If a version is provided in the workflow inputs, it uses that version.
      # - If no version is provided, it queries Azure for the latest available stable
      #   (non-preview) upgrade for the specified cluster.
      # - If no upgrades are available, it defaults to the cluster's current version.
      - name: Determine Target Kubernetes Version
        id: determine_version
        run: |
          RG="${{ github.event.inputs.resource_group }}"
          CLUSTER="${{ github.event.inputs.cluster_name }}"
          INPUT_VERSION="${{ github.event.inputs.aks_version }}"

          if [ -z "$INPUT_VERSION" ]; then
            echo "No specific version provided, querying for latest available non-preview upgrade..."
            LATEST_UPGRADE_VERSION=$(az aks get-upgrades --resource-group "$RG" --name "$CLUSTER" --query "controlPlaneProfile.upgrades[?isPreview==null].kubernetesVersion | sort(@) | [-1]" -o tsv)
            if [ -z "$LATEST_UPGRADE_VERSION" ] || [ "$LATEST_UPGRADE_VERSION" = "null" ]; then
              CURRENT_VERSION=$(az aks show --resource-group "$RG" --name "$CLUSTER" --query "kubernetesVersion" -o tsv)
              echo "No available non-preview upgrades found for $CLUSTER in $RG. Cluster is at $CURRENT_VERSION. Setting target to current version."
              TARGET_K8S_VERSION="$CURRENT_VERSION"
            else
              echo "Latest available non-preview upgrade version: $LATEST_UPGRADE_VERSION"
              TARGET_K8S_VERSION="$LATEST_UPGRADE_VERSION"
            fi
          else
            echo "Specific version provided: $INPUT_VERSION"
            TARGET_K8S_VERSION="$INPUT_VERSION"
          fi
          echo "Determined Target Kubernetes Version: $TARGET_K8S_VERSION"
          echo "TARGET_K8S_VERSION=$TARGET_K8S_VERSION" >> $GITHUB_OUTPUT
        shell: bash

      # Step 4: Create GitHub Issue for Tracking
      # Creates a GitHub Issue to provide a visible record of the upgrade process.
      # The issue body contains metadata about the cluster and a link to the workflow run.
      # This metadata is used by the `record-aks-upgrade.yml` workflow to check the status.
      - name: Create GitHub Issue for Tracking
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const rg = "${{ github.event.inputs.resource_group }}";
            const cluster = "${{ github.event.inputs.cluster_name }}";
            const targetVersion = "${{ steps.determine_version.outputs.TARGET_K8S_VERSION }}";
            const issueTitle = `AKS Upgrade: ${cluster} in ${rg} to ${targetVersion}`;
            const issueBody = `
            Tracking upgrade for Azure Kubernetes Service cluster.

            **Resource Group:** \`${rg}\`
            **Cluster Name:** \`${cluster}\`
            **Target Kubernetes Version:** \`${targetVersion}\`
            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            <!-- metadata
            resource_group: ${rg}
            cluster_name: ${cluster}
            target_version: ${targetVersion}
            -->
            `;
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['Ã¤ks-upgrade']
            });
            console.log(`Created issue for tracking: ${issue.html_url}`);
            core.setOutput('issue_number', issue.number);

      # Step 5: Update AKS Cluster
      # Initiates the AKS upgrade using the Azure CLI.
      # The `--no-wait` flag returns the command prompt immediately after the upgrade
      # operation is successfully initiated, without waiting for it to complete.
      - name: Update AKS Cluster
        run: |
          RG="${{ github.event.inputs.resource_group }}"
          CLUSTER="${{ github.event.inputs.cluster_name }}"
          VERSION="${{ steps.determine_version.outputs.TARGET_K8S_VERSION }}"
          echo "Attempting to upgrade $CLUSTER in $RG to version $VERSION"
          az aks upgrade --resource-group "$RG" --name "$CLUSTER" --kubernetes-version "$VERSION" --yes --no-wait
        shell: bash

      # Step 6: Verify AKS Cluster Upgrade Status
      # This step monitors the initial phase of the upgrade to catch immediate failures.
      # It checks the provisioning state of the cluster periodically.
      # - If the state becomes "Succeeded", it assumes the upgrade has started successfully.
      # - If the state becomes "Failed", it exits with an error.
      # - It times out after a set number of attempts to prevent long-running workflows.
      # Note: The final confirmation of the upgrade is handled by the `record-aks-upgrade.yml` workflow.
      - name: Verify AKS Cluster Upgrade Status
        run: |
          RG="${{ github.event.inputs.resource_group }}"
          CLUSTER="${{ github.event.inputs.cluster_name }}"
          ATTEMPTS=0
          MAX_ATTEMPTS=60 # ~30 minutes if interval is 30s
          INTERVAL=30
          EXPECTED_VERSION="${{ steps.determine_version.outputs.TARGET_K8S_VERSION }}"

          while true; do
            STATUS=$(az aks show --resource-group "$RG" --name "$CLUSTER" --query 'provisioningState' -o tsv)
            CURRENT_K8S_VERSION=$(az aks show --resource-group "$RG" --name "$CLUSTER" --query 'kubernetesVersion' -o tsv)
            echo "Cluster provisioning state: $STATUS"
            echo "Cluster Kubernetes version: $CURRENT_K8S_VERSION (Target: $EXPECTED_VERSION)"

            if [ "$STATUS" = "Succeeded" ]; then
              echo "Cluster provisioning Succeeded. Final version check will be done by the tracking issue monitor."
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "ERROR: Cluster upgrade process reported Failed state. Current state: $STATUS"
              exit 1
            fi
            ATTEMPTS=$((ATTEMPTS+1))
            if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
              echo "ERROR: Timed out waiting for cluster to reach a stable state post-upgrade initiation."
              exit 1
            fi
            echo "Waiting for upgrade to complete... ($ATTEMPTS/$MAX_ATTEMPTS)"
            sleep $INTERVAL
          done
        shell: bash
